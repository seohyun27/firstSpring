# 📌 자바 어노테이션 정리

## 📁 프로젝트 코드

### 📁 controller 패키지

#### 🔸클래스
- @Controller
  - 해당 클래스를 스프링 MVC의 컨트롤러로 등록한다 -> SpringConfig 파일을 통해 스프링 빈을 수동으로 등록하더라도 컨트롤러만큼은 해당 어노테이션을 통해 자동으로 등록해야 한다
  - 스프링 애플리케이션이 작동될 때, 해당 클래스가 스프링 빈으로 등록되어 스프링 컨테이너의 관리를 받는다
  - 해당 클래스 내부의 메소드는 HTTP 요청을 처리하는 핸들러 메서드로 동작된다
  - 하나의 스프링 애플리케이션에 여러 개의 컨트롤러가 등록되는 것이 일반적이다

#### 🔸 메소드
- @Autowired
  - 필드, 생성자, setter 메소드에 사용된다
  - 스프링 컨테이너와 관리하는 객체(스프링 빈)을 자동으로 주입해준다 = 의존성 주입 (프로그램 시작 시 해당 필드/생성자/메소드가 자동으로 실행된다)
  - 의존성 주입은 주로 생성자 주입을 권장한다 (final 키워드로 불변성 보장) -> 이 경우 생성자가 하나 뿐일 때는 @Autowired의 작성을 생략할 수 있다

- @GetMapping('/members/new')
  - 컨트롤러 클래스 아래 각 메소드에 작성
  - 클라이언트가 GET/members/new로 요청을 보내면 이 어노테이션이 붙은 메소드가 실행된다
  - 해당 URL 요청에 매핑된 컨트롤러 메서드가 존재하지 않는다면 static 파일의 index.html을 반환한다

- @ResponseBody
  - @GetMapping의 아래에서 작성
  - 해당 메소드의 리턴값을 HTTP 응답의 본문에 직접 넣겠다는 의미
  - 주로 API 개발을 위해 사용된다
  - 뷰(템플릿)을 반환하지 않고 JSON, String 등을 바로 반환한다

<br/>
<br/>

### 📂 repository 패키지

#### 🔸 클래스
- @Repository
  - 해당 클래스를 스프링 MVC의 레파지토리로 등록한다 -> SpringConfig를 통해 수동으로 @Bean 등록을 한다면 생략할 수 있다

#### 🔸 메소드
- @Autowired 
  - 컨트롤러와 마찬가지로 생성자가 하나뿐이라면 생략 가능하다

<br/>
<br/>

### 📂 domain 패키지 (JPA)
JPA(DB를 객체처럼 매핑)를 사용하기 위해 필요한 어노테이션들

#### 🔸 클래스
- @Entity
  - 클래스의 위에 선언. 해당 클래스를 JPA가 테이블로 매핑할 수 있도록 한다
  - 해당 클래스는 파라미터가 없는 기본 생성자를 반드시 가져야 한다

#### 🔸 필드
- @Id 
  - 클래스 내부 변수(필드)의 위에 선언
  - 해당 필드를 Primary Key로 지정한다. JPA는 이 id를 통해 객체를 구분한다.

- @GeneratedValue(strategy = GenerationType.IDENTITY)
  - @Id 필드와 함께 사용하며 자동 생성 전략을 지정한다
  - id의 값을 넣지 않으면 DB가 id값을 자동으로 생성한다.

<br/>
<br/>

### 📂 service 패키지

#### 🔸 클래스
- @Service 
  - 해당 클래스를 비즈니스 로직을 처리하는 서비스 계층으로 스프링에 등록한다
  - SpringConfig에서 수동으로 등록한다면 생략이 가능하다

#### 🔸 메소드/생성자
- @Autowired 
  - 마찬가지로 생성자가 하나라면 생략 가능하다

<br/>
<br/>

### 📂 Application

#### 🔸 클래스
- @SpringBootApplication
  - 해당 클래스를 스프링 부트의 어플리케이션으로 등록한다
  - 해당 클래스는 스프링 부트 애플리케이션의 진입점이 된다(Main 클래스)

<br/>
<br/>

### 📂 SpringConfig

#### 🔸 클래스
- @Configuration
  - 해당 클래스가 스프링 설정 클래스임을 명시한다
  - 내부에 정의된 @Bean 메소드들을 통해 수동으로 빈을 등록할 수 있다.

#### 🔸 메소드
- @Autowired
  - SpringConfig 내부에서 다른 빈을 주입받을 때 사용한다
  - SpringConfig의 생성자가 하나라면 생략 가능하다

- @Bean
  - 해당 메소드의 반환값을 스프링 컨테이너에 빈으로 등록한다
  - 메소드명이 빈의 이름이 된다

<br/>
<br/>

### 📂 aop 패키지

#### 🔸 클래스
- @Aspect
  - 해당 클래스를 AOP(공통 관심사 로직)의 핵심인 측면(Aspect)으로 등록

#### 🔸 메소드
- @Around("execution(경로)")
  - 지정된 pointcut(메서드 실행 지점)에 적용할 어드바이스(Advice)를 정의한다.
  - execution(경로)은 대상 메소드의 패키지, 이름, 매개변수 등을 지정하는 포인트컷 표현식이다
  - 컨트롤러, 도메인, 레파지토리, 서비스 패키지 내의 메소드들에 해당 어노테이션이 붙은 메소드들이 선택적으로 적용된다

#### 🔸 추가사항
- @Around 내의 ProceedingJoinPoint.proceed() 메소드는 원래 호출하려던 대상 메소드를 의미한다
- proceed() 전/후로 로직을 넣어 전처리/후처리 구현할 수 있다
- proceed()는 예외를 던지기 때문에 throws Throwable이 반드시 필요

<br/>
<br/>
<br/>
<br/>

## 📁 테스트 코드

#### 🔸 클래스
- @SpringBootTest
  - 스프링 부트 애플리케이션 전체를 실행해서 통합 테스트를 수행하도록 하는 어노테이션
  - 순수 자바 코드를 테스트 하는 단위 테스트의 경우 해당 어노테이션을 사용하지 않는다

- @Transactional
  - 위의 @SpringBootTest가 붙은 클래스에서 사용
  - 각 테스트 메서드 실행 전에 트랜잭션이 시작되고, 테스트 메서드가 끝나면 자동으로 롤백 -> DB에 테스트 기록을 남기지 않는다


#### 🔸 메소드
- @Test 
  - 해당 어노테이션이 붙은 메소드는 테스트 코드가 된다

- @Commit
  -  통합 테스트 환경 해당 어노테이션이 붙은 메소드는 클래스에 선언된 @Transactional을 무시하고 테스트 결과를 DB에 커밋하여 기록을 남긴다

- @BeforeEach 
  - 해당 어노테이션이 붙은 메소드는 각 테스트 메소드가 시작할 때마다 자동으로 실행된다

- @AfterEach 
  - 해당 어노테이션이 붙은 메소드는 각 테스트 메소드가 끝날 때마다 자동으로 실행된다
